This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
CMakeLists.txt
connection_pool.cpp
connection_pool.h
database.cpp
database.h
main_auth.cpp
main_file.cpp
net_auth.h
net.h
server_auth.cpp
server_auth.h
server.cpp
server.h
session_auth.cpp
session_auth.h
session.cpp
session.h
settings_auth.h
settings.h
vcpkg.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# This file is used to ignore files which are generated
# ----------------------------------------------------------------------------

*~
*.autosave
*.a
*.core
*.moc
*.o
*.obj
*.orig
*.rej
*.so
*.so.*
*_pch.h.cpp
*_resource.rc
*.qm
.#*
*.*#
core
!core/
tags
.DS_Store
.directory
*.debug
Makefile*
*.prl
*.app
moc_*.cpp
ui_*.h
qrc_*.cpp
Thumbs.db
*.res
*.rc
/.qmake.cache
/.qmake.stash

# qtcreator generated files
*.pro.user*
*.qbs.user*
CMakeLists.txt.user*

# xemacs temporary files
*.flc

# Vim temporary files
.*.swp

# Visual Studio generated files
*.ib_pdb_index
*.idb
*.ilk
*.pdb
*.sln
*.suo
*.vcproj
*vcproj.*.*.user
*.ncb
*.sdf
*.opensdf
*.vcxproj
*vcxproj.*

# MinGW generated files
*.Debug
*.Release

# Python byte code
*.pyc

# Binaries
# --------
*.dll
*.exe

#xml
*.xml


# Directories with generated files
.moc/
.obj/
.pch/
.rcc/
.uic/
/build*/
</file>

<file path="connection_pool.cpp">
#include "connection_pool.h"

std::shared_ptr<pqxx::connection> ConnectionPool::getConn()
{
    std::unique_lock<std::mutex> lock(mutex);
    while(pool.empty()){
        cond.wait(lock);
    }

    auto conn = pool.front();
    pool.pop();

    if(!conn->is_open()){
        conn = std::make_shared<pqxx::connection>(connection_str);
    }

    return conn;
}

void ConnectionPool::release(std::shared_ptr<pqxx::connection> oldConn)
{
    std::unique_lock<std::mutex> lock(mutex);
    pool.push(oldConn);
    lock.unlock();
    cond.notify_one();
}

ConnectionPool::ConnectionPool(std::string conn_str, size_t size) :
    connection_str(conn_str),
    pool_size(size)
{
    for(size_t i = 0; i < pool_size; ++i){
        try {
            auto conn = std::make_shared<pqxx::connection>(connection_str);
            if(conn->is_open()){
                pool.push(conn);
            }
        } catch (std::exception ex) {
            std::cerr << "Error in connection pool constructor: " << ex.what() << std::endl;
        }
    }
}
</file>

<file path="connection_pool.h">
#ifndef CONNECTION_POOL_H
#define CONNECTION_POOL_H
#include<pqxx/pqxx>
#include<queue>
#include<mutex>
#include<condition_variable>
#include<memory>
#include<iostream>

class ConnectionPool
{
    std::string connection_str;
    std::queue<std::shared_ptr<pqxx::connection>> pool;
    std::mutex mutex;
    std::condition_variable cond;
    size_t pool_size;
public:
    std::shared_ptr<pqxx::connection> getConn();
    void release(std::shared_ptr<pqxx::connection> oldConn);
    ConnectionPool(std::string conn_str, size_t size);
};

#endif // CONNECTION_POOL_H
</file>

<file path="database.h">
#ifndef DATABASE_H
#define DATABASE_H
#include <pqxx/pqxx>
#include <openssl/sha.h>
#include <openssl/evp.h>
#include <boost/asio.hpp>
#include <iostream>
#include <boost/uuid.hpp>
#include "connection_pool.h"
#include "settings.h"


class ScopedConnection{
    std::shared_ptr<pqxx::connection> conn;
    ConnectionPool& pool;

public:
    ScopedConnection(ConnectionPool& pool_);
    ~ScopedConnection();


    std::shared_ptr<pqxx::connection> operator ->();

    pqxx::connection& operator*();

};


class DataBase
{

    std::string connection_str;
    std::mutex db_mutex;

    std::unique_ptr<ConnectionPool> conn_pool;
    std::string hash_password(const std::string& password);
    std::string hash_uuid(const std::string& uuid);

    bool save_uuid(boost::uuids::uuid& uuid, size_t id);

public:
    bool register_user(const::std::string& username, const std::string& email,  const std::string& password, const std::string& uuid);
    bool logIn_user(const std::string& email, const::std::string& password);

    bool hash_compare_uuid(const std::string& user_UUID, size_t id);
    bool hash_compare_password(const std::string& user_password, const std::string& email);

    DataBase();
};






#endif // DATABASE_H
</file>

<file path="main_auth.cpp">
#include "server_auth.h"

int main(int argc, char *argv[])
{
    std::cout << "AUTHORIZATION" << std::endl;
    auto server = std::make_shared<Server_auth>();
    server->start();
}
</file>

<file path="main_file.cpp">
#include "server.h"

int main(int argc, char *argv[])
{
        std::cout << "FILE" << std::endl;
    auto server = std::make_shared<Server>();
    server->start();
}
</file>

<file path="net_auth.h">
#ifndef NET_AUTH_H
#define NET_AUTH_H
#include "boost/beast.hpp"
#include "boost/asio.hpp"
#include "boost/uuid.hpp"
#include "boost/asio/ssl.hpp"
#include "boost/beast/ssl/ssl_stream.hpp"
#include <nlohmann/json.hpp>
#include <iostream>
#include "settings.h"

using json = nlohmann::json;
namespace asio = boost::asio;
namespace beast = boost::beast;
namespace ip = asio::ip;
namespace http = beast::http;
namespace ssl = asio::ssl;
using uuid = boost::uuids::uuid;
using tcp = boost::asio::ip::tcp;



#endif // NET_AUTH_H
</file>

<file path="server_auth.cpp">
#include "server_auth.h"

#include "Server_auth.h"
#include "algorithm"


Server_auth::Server_auth()  :
    ioc(),
    acceptor(ioc),
    ctx(ssl::context::tls_server)
{
    boost::system::error_code er;
    acceptor.open(ip::tcp::endpoint{ip::make_address_v4(IP), PORT}.protocol(), er);

    if(er){
        throw std::runtime_error("error in open acceptor:" + er.what());
    }

    acceptor.set_option(asio::socket_base::reuse_address(true), er);
    if(er){
        throw std::runtime_error("error in open set option:" + er.what());
    }

    acceptor.bind(ip::tcp::endpoint{ip::make_address_v4(IP), PORT}, er);
    if(er){
        throw std::runtime_error("error in bind:" + er.what());
    }

    acceptor.listen(asio::socket_base::max_listen_connections, er);
    if(er){
        throw std::runtime_error("error in listen:" + er.what());
    }


}


void Server_auth::start_acceptor()
{

    auto sock = std::make_shared<ip::tcp::socket>(ioc);
    auto self = shared_from_this();
    acceptor.async_accept(*sock, [self, sock](boost::system::error_code er){
        if(!er){
            auto session = std::make_shared<Session_auth>(*self, sock, self->ctx);
            session->run();
            self->start_acceptor();
        }else{
            throw std::runtime_error("error in accept: " + er.message());
        }
    });
}

void Server_auth::start()
{

    load_server_certificate(ctx);
    start_acceptor();

    unsigned int threads = std::max(1u, std::thread::hardware_concurrency());
    std::vector<std::thread> pool;
    pool.reserve(threads);
    auto self = shared_from_this();
    for(int i = 0 ; i < threads; ++i){
        pool.emplace_back([self]() -> void{
            try {
                self->ioc.run();
            }
            catch (std::exception ex) {
                std::cerr << "error int start poll threads: " << std::endl;
            }
        });
    }


    for(auto& t : pool){
        t.join();
    }
}


void Server_auth::load_server_certificate(asio::ssl::context& contx){
    try {
        contx.set_options(asio::ssl::context::default_workarounds |
                          asio::ssl::context::no_sslv2 |
                          asio::ssl::context::single_dh_use);
        contx.use_certificate_chain_file("Server_auth.crt");
        contx.use_private_key_file("Server_auth.key", asio::ssl::context::pem);
    }
    catch (std::exception ex) {
        std::cout << "exception in load certificate" << std::endl;
    }

}
</file>

<file path="server_auth.h">
#ifndef SERVER_AUTH_H
#define SERVER_AUTH_H
#include "net_auth.h"
#include "database.h"
#include "session_auth.h"

class Server_auth : public std::enable_shared_from_this<Server_auth>
{

    asio::io_context ioc;
    ip::tcp::acceptor acceptor;
    std::mutex mtx;
    ssl::context ctx;

    void start_acceptor();

public:
    DataBase database;
    void start();
    void load_server_certificate(asio::ssl::context& contx);
    Server_auth();
};


#endif // SERVER_AUTH_H
</file>

<file path="session_auth.cpp">
#include "session_auth.h"
#include "server_auth.h"
#include "iostream"



Session_auth::Session_auth(Server_auth& server, std::shared_ptr<ip::tcp::socket> socket, asio::ssl::context& contx) :
    server(server),
    ssl_stream(std::move(*socket), contx),
    buff(4096)
{
    stream_timer = std::make_shared<asio::steady_timer>(ssl_stream.get_executor());
}

void Session_auth::run()
{
    auto self = shared_from_this();
    ssl_stream.async_handshake(ssl::stream_base::server,
                               [self](boost::system::error_code er){
                                   if(!er){
                                       self->do_read();
                                   }else{
                                       std::cerr << "error in handshake: " << er.what() << std::endl;
                                   }
                               });
}

void Session_auth::do_read()
{
    req = {};
    auto self = shared_from_this();
    http::async_read(ssl_stream,
                     buffer,
                     req,
                     [self](beast::error_code er, size_t bytes){
                         boost::ignore_unused(bytes);
                         if(!er){
                             if(self->req.method() == http::verb::get && self->req.target() == "/music.mp3"){
                                 self->start_streaming();
                             }else{
                                 self->handle_api();
                             }
                         }
                         else if(er == http::error::end_of_stream || er == asio::ssl::error::stream_truncated){ self->do_close(); }
                         else{
                             std::cerr << "error in asyc read: " << er.what() << std::endl;
                         }
                     });
}

void Session_auth::handle_api(){
    json json_resp;
    http::status status = http::status::ok;

    auto target = req.target();
    auto method = req.method();

    if(target == "/api/status" && method == http::verb::get){
        json_resp = {{"status", "online"}, {"secure", true}};
    }

    else if(method == http::verb::get && target == "/music.mp3"){

    }

    else{
        status = http::status::not_found;
        json_resp = {"status", "not found"};
    }

    auto resp = std::make_shared<http::response<http::string_body>>(status, req.version());
    resp->set(http::field::server, "asio Igore-Corp authenticate server");
    resp->set(http::field::content_type, "application/json");
    resp->keep_alive(req.keep_alive());
    resp->body() = json_resp.dump();
    resp->prepare_payload();

    auto self = shared_from_this();

    http::async_write(ssl_stream, *resp,
                      [self, resp](beast::error_code er, size_t bytes){
                          if(!resp->keep_alive()){
                              self->do_close();
                          }else if(!er){
                              self->do_read();
                          }else if(er){
                              std::cerr << "error in handle write: " << er.what() << std::endl;
                          }
                      });

}


void Session_auth::start_streaming(){
    auto resp = std::make_shared<http::response<http::empty_body>>(http::status::ok, req.version());
    resp->set(http::field::server, "Streaming server music.mp3");
    resp->set(http::field::content_type, "audio/mpeg");
    resp->chunked(true);

    auto ser = std::make_shared<http::response_serializer<http::empty_body>>(*resp);

    auto self = shared_from_this();
    http::async_write_header(ssl_stream, *ser,
                             [self, resp, ser](beast::error_code er, size_t bytes){
                                 if(!er){
                                     self->open_file_read();
                                     self->stream_loop();
                                 }else{
                                     std::cerr << "error in start streaming: " << er.what() << std::endl;
                                 }
                             });
}

void Session_auth::stream_loop()
{

    int readed = read_file_chunk();

    if(readed <= 0){
        auto final_chunk = http::make_chunk_last();
        auto self = shared_from_this();

        asio::async_write(ssl_stream, final_chunk,
                          [self](boost::system::error_code er, size_t bytes){
                              if(!er){
                                  self->do_read();
                              }
                          });
        return;
    }



    auto chunk_data = http::make_chunk(beast::net::buffer(buff, readed));
    auto self = shared_from_this();



    asio::async_write(ssl_stream, chunk_data,
                      [self](beast::error_code err, size_t bytes){
                          if(!err){
                              self->stream_timer->expires_after(std::chrono::milliseconds(50));
                              self->stream_timer->async_wait([self](boost::system::error_code err1){
                                  if(!err1){
                                      self->stream_loop();
                                  }else{
                                      std::cerr << "error in async wait: " << err1.what() << std::endl;
                                  }
                              });
                          }else{
                              std::cerr << "error in stream loop: " << err.what() << std::endl;
                          }
                      });

}

void Session_auth::open_file_read()
{
    file_stream.open("music.mp3", std::ios::in | std::ios::binary);
    if(!file_stream.is_open()){
        std::cerr << "File Not Open "  << std::endl;
    }
}

std::streamsize Session_auth::read_file_chunk()
{
    if(file_stream.eof()){ return 0; }
    file_stream.read(buff.data(), buff.size());
    return file_stream.gcount();
}

boost::uuids::uuid Session_auth::generate_uuid()
{
    boost::uuids::basic_random_generator<std::mt19937> gen;
    return gen();
}

void Session_auth::do_close()
{
    auto self = shared_from_this();
    ssl_stream.async_shutdown([self](beast::error_code er){
        if(er == beast::net::error::eof){ er = {}; }
        if(er){
            std::cerr << "error in shutdown: " << er.what() << std::endl;
        }
    });
}
</file>

<file path="session_auth.h">
#ifndef SESSION_AUTH_H
#define SESSION_AUTH_H
#include "net.h"
#include "fstream"
#include "boost/uuid.hpp"

class Server_auth;


class Session_auth : public std::enable_shared_from_this<Session_auth>
{
    std::fstream file_stream;
    Server_auth& server;
    asio::ssl::stream<tcp::socket> ssl_stream;
    beast::flat_buffer buffer;
    http::request<http::string_body> req;
    std::vector<char> buff;
    std::shared_ptr<asio::steady_timer> stream_timer;
    void do_read();
    void do_close();

    void start_streaming();

    void handle_api();

    void stream_loop();

    void open_file_read();
    std::streamsize  read_file_chunk();

    boost::uuids::uuid generate_uuid();

public:
    Session_auth(Server_auth& server, std::shared_ptr<ip::tcp::socket> socket, asio::ssl::context& contx);
    void run();
};



#endif // SESSION_AUTH_H
</file>

<file path="settings_auth.h">
#ifndef SETTINGS_AUTH_H
#define SETTINGS_AUTH_H
#include<string.h>

const std::string IP = "127.0.0.1";
const int PORT = 55556;
const size_t SQL_CONNECT_POOL_SIZE = 5;
#endif // SETTINGS_AUTH_H
</file>

<file path="settings.h">
#ifndef SETTINGS_H
#define SETTINGS_H
#include<string.h>

const std::string IP = "127.0.0.1";
const int PORT = 55555;
const size_t SQL_CONNECT_POOL_SIZE = 5;

#endif // SETTINGS_H
</file>

<file path="CMakeLists.txt">
cmake_minimum_required(VERSION 3.16)

project(file-manager-server-webRtcp LANGUAGES CXX)

set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Boost REQUIRED)
find_package(GTest REQUIRED)
find_package(OpenSSL REQUIRED)
find_package(nlohmann_json REQUIRED CONFIG)
find_package(libpqxx REQUIRED)
find_package(jwt-cpp REQUIRED CONFIG)

add_library(file-manager-server-lib
  server.h server.cpp
  net.h
  session.h session.cpp
  settings.h
)
target_link_libraries(file-manager-server-lib PUBLIC
  Boost::boost
  OpenSSL::SSL
  nlohmann_json::nlohmann_json
  libpqxx::pqxx)

add_library(auth-manager-server-lib
  connection_pool.h connection_pool.cpp
  database.h database.cpp
  server_auth.h server_auth.cpp
  net_auth.h
  session_auth.h session_auth.cpp
  settings_auth.h
)

target_link_libraries(auth-manager-server-lib PUBLIC
  Boost::boost
  OpenSSL::SSL
  nlohmann_json::nlohmann_json
  libpqxx::pqxx
  jwt-cpp::jwt-cpp
)

add_executable(auth-manager-server
  main_auth.cpp
)

target_link_libraries(auth-manager-server auth-manager-server-lib)



add_executable(file-manager-server
  main_file.cpp
)
target_link_libraries(file-manager-server file-manager-server-lib)
</file>

<file path="server.h">
#ifndef Server_H
#define Server_H
#include "net.h"
#include "mutex"
#include "session.h"
#include <forward_list>
#include "database.h"

class Server : public std::enable_shared_from_this<Server>
{

    asio::io_context ioc;
    ip::tcp::acceptor acceptor;
    std::mutex mtx;
    std::forward_list<std::shared_ptr<Session>> sessions;
    ssl::context ctx;

    void start_acceptor();

public:
    void start();
    void load_server_certificate(asio::ssl::context& contx);
    Server();
};

#endif // Server_H
</file>

<file path="session.h">
#ifndef SESSION_H
#define SESSION_H
#include "net.h"
#include "fstream"
#include "boost/uuid.hpp"

class Server;


class Session : public std::enable_shared_from_this<Session>
{
    std::fstream file_stream;
    Server& server;
    asio::ssl::stream<tcp::socket> ssl_stream;
    beast::flat_buffer buffer;
    http::request<http::string_body> req;
    std::vector<char> buff;
    std::shared_ptr<asio::steady_timer> stream_timer;
    void do_read();
    void do_close();

    void start_streaming();

    void handle_api();

    void stream_loop();

    void open_file_read();
    std::streamsize  read_file_chunk();

    boost::uuids::uuid generate_uuid();

public:
    Session(Server& server, std::shared_ptr<ip::tcp::socket> socket, asio::ssl::context& contx);
    void run();
};

#endif // SESSION_H
</file>

<file path="vcpkg.json">
{
  "name": "file-manager-server",
  "version-string": "1.0.0",
  "dependencies": [
    "gtest",
    "boost-asio",
    "boost-beast",
    "openssl",
    "boost-uuid",
    "nlohmann-json",
    "libpqxx",
    "jwt-cpp"
  ]
}
</file>

<file path="net.h">
#ifndef NET_H
#define NET_H
#include "boost/beast.hpp"
#include "boost/asio.hpp"
#include "boost/uuid.hpp"
#include "boost/asio/ssl.hpp"
#include "boost/beast/ssl/ssl_stream.hpp"
#include <nlohmann/json.hpp>
#include <iostream>
#include "settings.h"

using json = nlohmann::json;
namespace asio = boost::asio;
namespace beast = boost::beast;
namespace ip = asio::ip;
namespace http = beast::http;
namespace ssl = asio::ssl;
using uuid = boost::uuids::uuid;
using tcp = boost::asio::ip::tcp;




#endif // NET_H
</file>

<file path="server.cpp">
#include "Server.h"
#include "algorithm"


Server::Server()  :
    ioc(),
    acceptor(ioc),
    ctx(ssl::context::tls_server)
{
    boost::system::error_code er;
    acceptor.open(ip::tcp::endpoint{ip::make_address_v4(IP), PORT}.protocol(), er);

    if(er){
        throw std::runtime_error("error in open acceptor:" + er.what());
    }

    acceptor.set_option(asio::socket_base::reuse_address(true), er);
    if(er){
        throw std::runtime_error("error in open set option:" + er.what());
    }

    acceptor.bind(ip::tcp::endpoint{ip::make_address_v4(IP), PORT}, er);
    if(er){
        throw std::runtime_error("error in bind:" + er.what());
    }

    acceptor.listen(asio::socket_base::max_listen_connections, er);
    if(er){
        throw std::runtime_error("error in listen:" + er.what());
    }


}


void Server::start_acceptor()
{

    auto sock = std::make_shared<ip::tcp::socket>(ioc);
    auto self = shared_from_this();
    acceptor.async_accept(*sock, [self, sock](boost::system::error_code er){
        if(!er){
            auto session = std::make_shared<Session>(*self, sock, self->ctx);
            session->run();
            self->start_acceptor();
        }else{
            throw std::runtime_error("error in accept: " + er.message());
        }
    });
}

void Server::start()
{

    load_server_certificate(ctx);
    start_acceptor();

    unsigned int threads = std::max(1u, std::thread::hardware_concurrency());
    std::vector<std::thread> pool;
    pool.reserve(threads);
    auto self = shared_from_this();
    for(int i = 0 ; i < threads; ++i){
        pool.emplace_back([self]() -> void{
            try {
                self->ioc.run();
            }
            catch (std::exception ex) {
                std::cerr << "error int start poll threads: " << std::endl;
            }
        });
    }


    for(auto& t : pool){
        t.join();
    }
}


void Server::load_server_certificate(asio::ssl::context& contx){
    try {
            contx.set_options(asio::ssl::context::default_workarounds |
                asio::ssl::context::no_sslv2 |
                asio::ssl::context::single_dh_use);
            contx.use_certificate_chain_file("server.crt");
            contx.use_private_key_file("server.key", asio::ssl::context::pem);
    }
    catch (std::exception ex) {
        std::cout << "exception in load certificate" << std::endl;
    }

}
</file>

<file path="session.cpp">
#include "session.h"
#include "server.h"
#include "iostream"



Session::Session(Server& server, std::shared_ptr<ip::tcp::socket> socket, asio::ssl::context& contx) :
    server(server),
    ssl_stream(std::move(*socket), contx),
    buff(4096)
{
    stream_timer = std::make_shared<asio::steady_timer>(ssl_stream.get_executor());
}

void Session::run()
{
    auto self = shared_from_this();
    ssl_stream.async_handshake(ssl::stream_base::server,
                               [self](boost::system::error_code er){
                                   if(!er){
                                       self->do_read();
                                   }else{
                                       std::cerr << "error in handshake: " << er.what() << std::endl;
                                   }
                               });
}

void Session::do_read()
{
    req = {};
    auto self = shared_from_this();
    http::async_read(ssl_stream,
                     buffer,
                     req,
                     [self](beast::error_code er, size_t bytes){
                         boost::ignore_unused(bytes);
                         if(!er){
                            if(self->req.method() == http::verb::get && self->req.target() == "/music.mp3"){
                                self->start_streaming();
                            }else{
                                self->handle_api();
                            }
                         }
                         else if(er == http::error::end_of_stream || er == asio::ssl::error::stream_truncated){ self->do_close(); }
                         else{
                            std::cerr << "error in asyc read: " << er.what() << std::endl;
                         }
                     });
}

void Session::handle_api(){
    json json_resp;
    http::status status = http::status::ok;

    auto target = req.target();
    auto method = req.method();

    if(target == "/api/status" && method == http::verb::get){
        json_resp = {{"status", "online"}, {"secure", true}};
    }

    else if(method == http::verb::get && target == "/music.mp3"){

    }

    else{
        status = http::status::not_found;
        json_resp = {"status", "not found"};
    }

    auto resp = std::make_shared<http::response<http::string_body>>(status, req.version());
    resp->set(http::field::server, "asio Igore-Corp Server");
    resp->set(http::field::content_type, "application/json");
    resp->keep_alive(req.keep_alive());
    resp->body() = json_resp.dump();
    resp->prepare_payload();

    auto self = shared_from_this();

    http::async_write(ssl_stream, *resp,
                      [self, resp](beast::error_code er, size_t bytes){
        if(!resp->keep_alive()){
            self->do_close();
        }else if(!er){
            self->do_read();
        }else if(er){
            std::cerr << "error in handle write: " << er.what() << std::endl;
        }
    });

}


void Session::start_streaming(){
    auto resp = std::make_shared<http::response<http::empty_body>>(http::status::ok, req.version());
    resp->set(http::field::server, "Streaming server music.mp3");
    resp->set(http::field::content_type, "audio/mpeg");
    resp->chunked(true);

    auto ser = std::make_shared<http::response_serializer<http::empty_body>>(*resp);

    auto self = shared_from_this();
    http::async_write_header(ssl_stream, *ser,
                             [self, resp, ser](beast::error_code er, size_t bytes){
        if(!er){
            self->open_file_read();
            self->stream_loop();
        }else{
            std::cerr << "error in start streaming: " << er.what() << std::endl;
        }
    });
}

void Session::stream_loop()
{

    int readed = read_file_chunk();

    if(readed <= 0){
        auto final_chunk = http::make_chunk_last();
        auto self = shared_from_this();

        asio::async_write(ssl_stream, final_chunk,
                          [self](boost::system::error_code er, size_t bytes){
            if(!er){
                self->do_read();
            }
        });
        return;
    }



    auto chunk_data = http::make_chunk(beast::net::buffer(buff, readed));
    auto self = shared_from_this();



    asio::async_write(ssl_stream, chunk_data,
                       [self](beast::error_code err, size_t bytes){
        if(!err){
            self->stream_timer->expires_after(std::chrono::milliseconds(50));
            self->stream_timer->async_wait([self](boost::system::error_code err1){
                if(!err1){
                    self->stream_loop();
                }else{
                    std::cerr << "error in async wait: " << err1.what() << std::endl;
                }
            });
        }else{
            std::cerr << "error in stream loop: " << err.what() << std::endl;
        }
    });

}

void Session::open_file_read()
{
    file_stream.open("music.mp3", std::ios::in | std::ios::binary);
    if(!file_stream.is_open()){
        std::cerr << "File Not Open "  << std::endl;
    }
}

std::streamsize Session::read_file_chunk()
{
    if(file_stream.eof()){ return 0; }
    file_stream.read(buff.data(), buff.size());
    return file_stream.gcount();
}

boost::uuids::uuid Session::generate_uuid()
{
    boost::uuids::basic_random_generator<std::mt19937> gen;
    return gen();
}

void Session::do_close()
{
    auto self = shared_from_this();
    ssl_stream.async_shutdown([self](beast::error_code er){
        if(er == beast::net::error::eof){ er = {}; }
        if(er){
            std::cerr << "error in shutdown: " << er.what() << std::endl;
        }
    });
}
</file>

</files>
